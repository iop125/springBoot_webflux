web反应式框架


Spring WebFlux是一个自底向上构建的非阻塞Web框架，用于利多核、下一代处理器并处理大量并发连接
j2ee7以上 同时不支持关系型数据库

Mono 表示包含0或1个元素的异步序列
    fromSupplier  提供者可以理解为返回  是函数编程里面的东西
Flux 表示可以包含0或多个元素的异步序列

########################################################

SSE
规范是 HTML 5 规范的一个组成部分。该规范比较简单，主要由两个部分组成：
 服务端与浏览器之间的通讯协议
 浏览器 中 可供 JavaScript 使用的 EventSource 对象

（1） 通讯协议
这个
通讯协议是基于纯文本的简单协议。服务器端的响应内容类型 必须 是
“text/event stream” 。响应文本的内容是一个事件流，事件流是一个简单的文本流，仅支持
UTF 8 格式的编码。
事件流由不同的事件
组成。不同事件间通过仅包含回车符和换行符的空行（ r n”n”）来
分隔。
每个事件
可以由多行构成， 每 行 由类型和数据 两部分组成。类型与 数据通过 冒号（
进行分隔，冒号前的为类型，冒号后的为其对应的值。每个事件可以包含如下 类型 的行
 类型为空白，表示该行是注释，会在处理时被忽略。
 类型为 data ，表示该行 是事件所 包含的数据。以 data 开头的行可以出现多次。所有
这些行都是该事件的数据。
 类型为 event ，表示该行用来声明事件的类型 ，即事件名称 。浏览器在收到数据时，会
产生对应 名称 的事件。
 类型为 id ，表示该行用来声明事件的标识符。
 类型为 retry ，表示该行用来声明浏览器在连接断开之后进行 重连的等待时间

data:china // 该事件仅包含数据
data:Beijing // 该事件包含数据与事件标识
id: 100
event: myevent      // 该事件指定了名称
data:shanghai
id: 101
: this is a comment     // 该事件具有注释、名称，且包含两行数据
event:city
data:guangzhou
data:shenzhen

事件标识 id 有什么用呢？
如果服务
端 发送的事件 中包含 事件标识 id 那么 浏览器会 将 最近一次接收到的事件标识
id 记录到 HTTP 头 的 Last Event ID 属性中 。如果 浏览器与服务 端的连接中断，当浏览器再次
连接时，会 将 Last Event ID 记录的事件 标识 id 发送给服务端 。服务器端通过浏览器端发送
的事件标识 id 来确定 将 继续连接 哪个事件

EventSource 对象
    页面对于服务端
    发送的带有事件的 响应，浏览器需要在 JavaScript 中使用 EventSource 对象
    进行处理。 EventSource 使用的是标准的事件监听器方式 （注意，这里的事件并不是响应中
    所带的事件，而是浏览器上所 发生的事件）。当相应的事件发生时， 只需 使 EventSource 对象
    调用 相应的事件处理方法即可。 EventSource 提供了三个标准事件

     open  当浏览器成功与服务端建立连接时触发    onopen()
     message 当收到服务端发送的事件时触发   onmessage()  addEventListener()
     error   当发生异常时触发   onerror()
     例子
     servlet SSEServlet 页面：index.jsp

########################################################
Reactive Stream

推拉模型和背压
    在流处理机制 中 push （推送 模型和 pull （拉取 模型是最常见的。 push 模型中，发
    布者将元素 主动 推送给订阅者。 而 pull 模式中，订阅者 会向发布者主动索要 。 在同步式系统
    中发布者与订阅者的工作效率相当，发布者发布一个消息后阻塞，等待订阅者消费。订阅者
    消费完后，订阅者阻塞，等待发布者发布。这种同步式处理方式效率 很低。一般使用的是异
    步消息处理机制。即 发布者发布消息，与消费者消费消息的速度是不一样的。那么它们间是
    如何协调工作的呢？
    当订阅者 比发布者快时，会出现订阅者无消息可消费的情况。 在同步 数据处理机制 中订
    阅者 需无限期 等待，直到有 消息 可用。 但在异步处理机制中，订阅者无需阻塞，其 继续处理
    其他任务 即可 。当 出现了 准备就绪 的消息 时，发布者 会 将它们异步发送给订阅者。 所以，在
    异步处理机制中，这种情况并不会对系统性能产生负面影响。
    当发布者比订阅者快时有两大类解决方案。
        一类解决方案是改变订阅者。
          要么使 订阅者 拥有一个无边界缓冲区来保存快速传入的消息，要么让订阅者将 它无法处理的 消息丢弃 。
        另一类解决方案是改变发布者。这类解决方案采用的策略称为
            背压（ B ack P ressure ）策略 。 订阅者告诉发布者 让其 减慢 发布速度并保持消息，直到订阅者准备好处理更多消息 。使
            用背压 策略 可确保 较 快的发布者不会压制较慢的订阅者。 但该解决方案要求 发布者 要 拥有无
            限制缓冲区， 以确保发布者可以 一直 生产 和保存 消息 。 当然， 发布者 也 可以实现有界缓冲区
            以 保存有限数量的 消息。但若 缓冲区满， 则需要放弃这些消息 。 不过，可以让发布者将放弃
            的消息再发布，直到订阅 将其消费。
反应式流
        反应式流从 2013 年开始，作为提供非阻塞背压的异步流处理标准的倡议， 旨在解决处
    理元素流 （即消息流、数据流 的问题 如何将元素流从发布者传递到订阅者，而不需要
    发布者阻塞，或订阅者有无限制的缓冲区或丢弃。
        反应式流模型非常简单 ：订阅者向发布者发送多个元素的异步请求 发布者向订阅者异
    步发送多个或稍少的元素。 反应式流会在 pull 模型和 push 模型流处理机制之间动态切换。
    当发布者快、订阅者慢时，它使用 pull 模型；当发布者慢、订阅者快时，它使用 push 模型。
    即谁慢谁占主动
背压
     即使谁慢谁占主动
反应式流接口
    1。Publisher<T>接口
        Publisher ，即发布者，是有序消息的生产者。它根据收到的请求向订阅者发布消息。
    2。Subscriber，即订阅者，从发布者那里订阅并接收消息。发布者向订阅者发送订阅令牌Subscription ）。
        使用订阅令牌，订阅者可以从发布者那里请求多个消息。当消息元素准备
        就绪时，发布者向订阅者发送多个或更少的元素。然后订阅者可以再次请求更多的消息元素，
        或取消订阅。一个 发布者可能需要处理来自多个订阅者的请求。
    3。Subscription 接口
        Subscription 订阅费 ))，订阅令牌。当订阅请求成功时，发布者将其传递给订阅者。订阅
        者使用订阅令牌与发布者进行交互，例如请求更多的消息元素或取消订阅。
    4。三个接口的关系
        Subscriber --->Subscribes(订阅消息)————>Publisher （建立连接）
        Publisher ---> sends a subscription  (发送订阅令牌-信息放在令牌中)--->Subscriber
        重复这过程 最后
        Publisher————> sends an  end of stream notification (发送一个流结束的通知)---->Subscriber
    5。Processor<T,R>接口
            Processor，即处理器，充当订阅者和发布者的处理阶段。 Processor 接口继承了 Publisher
        和 Subscriber 接口。它用于转换发布者 订阅者管道中的元素。 Processor<T, R> 会将来自于发
        布者的 T 类型的消息数据，接收并转换为 R 类型的数据，并将转换后的 R 类型数据发布给订
        阅者。 一个发布者可以拥有多个处理者。

        Publisher --(T)-->  Processor--(R)-->Subscriber

    java提供了SubnissionPubisher 这个类作为发布者


########################################################
异步serlet
AsynchronousServlet
    步骤：
    1。在启动类上面加载 @ServletComponentScan和@EnableAsync注解
    2。倒入jar包
    3。extends HttpServlet
    4。asyncSupported = true
    5。获取异步上下文，开启异步操作
    6。设置异步时间
    7。获取非阻塞的异步请求和响应
    8。 CompletableFuture.runAsync(() -> doSome(asyncContext, servletRequest, servletResponse));执行

同步servlet
SynchronizationServlet

